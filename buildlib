#!/bin/bash -
#-----------------------------------------------------#
# buildlib
#
# Builds a portable library for shell script programs.
#-----------------------------------------------------#
#-----------------------------------------------------#
# Licensing
# ---------
# 
# Copyright (c) 2013 Vokayent
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#-----------------------------------------------------#
BINDIR="$(dirname "$(readlink -f $0)")"
SELF="$(readlink -f $0)"
LIB="${BINDIR}/lib.complete"
source $LIB
PROGRAM="buildlib"

# usage() - Show usage message and die with $STATUS
usage() {
   STATUS="${1:-0}"
   echo "Usage: ./${PROGRAM}
	[ -  ]

Library Compile Actions:
-k | --link-at <arg>          Link what is chosen at a certain directory.
-kw| --link-with <arg>        Link with the <arg> compiled in.
-w | --with <arg>             Build library with functions listed in <arg> 
-x | --without <arg>          Build library with functions listed in <arg> 
-z | --all-libs               Build library with functions listed in <arg> 
-n | --name <arg>             Give the library and its elements a consistent 
                              name.
-q | --namespace <arg>        Build library functions with a different 
                              naming convention.
-c | --comments               Include comments in library. (default includes comments :) )
-l | --list                   List all available functions. 
-? | --describe <arg>         Describe function <arg>.
--specify-with                Use a menu to choose library list.

Library Runtime Actions:
-e | --executables <arg>      Convert names in <arg> to variables that alias
                              programs located in your \$PATH
-s | --static <arg>           Convert names in <arg> to variables pointing to 
                              immutable values. 
-ff| --functions-for <list> Generate some skelelon functions.
                            ( echo '...' is default )
-d | --depcheck               Generate code to run a dependency check.
-s | --standard_dirs <arg>    Convert names in <arg> to variables that 
                              reference your program's common directories.
-b | --db                     Generate code to create a database. 
-t | --initial-run            Generate code to run preliminary checks in a 
                              shell script.
-y | --initial-install <dir>  Generate code to install a shell script.
                              ( /usr/bin, /usr/local/bin or $HOME/bin )
-u | --security               Generate code to secure a shell script.
-a | --set-all <arg>          Set all flags that do not require an argument.
                              <arg> refers to library name.

General Options:
-v | --verbose                Be verbose in output.
-h | --help                   Show this help and quit.
"
   exit $STATUS
}

#------------------------------------------------------
# generate_library_file() 
# 
# Generates a file at the top level of some library.
#-----------------------------------------------------#
generate_library_file() {
	# Start an array.
	echo '...'
}

# Die if no arguments received.
[ -z "$BASH_ARGV" ] && printf "Nothing to do\n" && usage 1


# Still to do, add --regen for rebuilding libraries.
# add --update to initial_install (to rebuild tables and add any new directories that may be part of script.)
# documenting individual libraries ( --libusage )

# Process options.
declare -a DO_BUILD
while [ $# -gt 0 ]
do
   case "$1" in
		# ...
	  -a|--set-all)
			SET_ALL=true
			DO_COMMENTS=true
         DO_DB=true
         DO_INITIAL_RUN=true
         DO_INITIAL_INSTALL=true
         DO_SECURITY=true
			shift
			LIBNAME="$1"
		;;

	  -kw|--link-with)
		  shift
		  LINK_WITH="$1"
		;;

	  -k|--link-at)
		  DO_LINKING=true
		  shift
		  LINK_AT="$1"
		;;

	  -c|--comments)
			DO_COMMENTS=true
		;;

     -w|--with)
         DO_WITH=true
         shift
         WITH="$1"
      ;;

     -x|--without)
         shift
         WITHOUT="$1"
      ;;

     -z|--all)
         DO_INC_ALL=true
      ;;

     -l|--list)
         DO_LIST=true
         shift
         LIST="$1"
      ;;

     -n|--name)
         shift
         LIBNAME="$1"
      ;;

     -q|--namespace)
         DO_NAMESPACE=true
         shift
         NAMESPACE="$1"
      ;;

     --specify-with)
         DO_WITH=true
         DO_SPECIFY_WITH=true
      ;;

     -e|--executables)
         DO_EXECUTABLES=true
         shift
         EXECUTABLES="$1"
      ;;

     -s|--static)
         DO_STATIC=true
         shift
         STATIC="$1"
      ;;

     -d|--depcheck)
         DO_DEPCHECK=true
      ;;

     -t|--standard-dirs)
         DO_STANDARD_DIRS=true
         shift
         STANDARD_DIRS="$1"
      ;;

     -b|--db)
         DO_DB=true
      ;;

	  -yy|--initial-install)
			DO_INITIAL_INSTALL=true
			shift
			INITIAL_INSTALL_DIR="$1"
		;; 

	  -y|--initial-install-dir)
			shift
			INITIAL_INSTALL_DIR="$1"
		;;

     -i|--initial-run)
         DO_INITIAL_RUN=true
      ;;

		-ff|--functions-for)
			DO_FUNCTIONS=true
			shift
			FUNCTION_LIST="$1"
		;;

     -s|--security)
         DO_SECURITY=true
      ;;

     --describe)
         DO_DESCRIBE=true
         shift
         DESCRIBE="$1"
      ;;

		# Library build functions.
     --from-class)
         DO_BUILD[${#DO_BUILD[@]}]="databases"
         DO_BUILD[${#DO_BUILD[@]}]="arguments"
         DO_BUILD[${#DO_BUILD[@]}]="random"
         DO_BUILD[${#DO_BUILD[@]}]="strings"
         DO_BUILD[${#DO_BUILD[@]}]="integers"
         DO_BUILD[${#DO_BUILD[@]}]="math"
         DO_BUILD[${#DO_BUILD[@]}]="arrays"
		;;	

		# General options.
      -v|--verbose)
        VERBOSE=true
      ;;
      -h|--help)
        usage 0
      ;;
      --)
		break
     ;;
      -*)
      printf "Bad argument.\n";
      exit 1
     ;;
      *) break;;
   esac
shift
done


# Verbosity
eval_flags


# list
if [ ! -z $DO_LIST ]
then
	# Regen doc.
#	while read line
#	do
#		# Save this b/c it's our folder name for different lib functions.
#		if [[ ${line:0:1} == '#' ]] 
#		then
#			printf "\nIn $(echo $line | sed 's/# //' | tr [A-Z] [a-z] ) library:\n"
#			continue
#
#		# Move through blanks.
#		elif [[ -z "${line}" ]]
#		then
#			continue	
#
#		# You have hit gold...
#		else
#			printf "  $line" | \
#				sed 's/\r//' | \
#				awk -F ':' '{print $1 ":          "}' | \
#				head -c 25 
#			printf "$line" | awk -F ':' '{print $2}' 
#		fi
#	done < $LIB_MANIFEST

	dbm --select 'name' --from libs
fi


# Describe one thing at a time.
if [ ! -z $DO_DESCRIBE ]
then
	[ -z "$DESCRIBE" ] && echo "No description supplied!" && usage 1
	grep "$DESCRIBE" $LIB_MANIFEST
fi


# Licenses can still be included as well as banners.
# ...


# Finally, add an individual usage.
# Easy to lose track of all of this and even how to use everything.
# For functions that ship with this, just maintain a help file within the code.
# For functions that do not ship with this (e.g. dependencies from elsewhere or items added 
# through maintlib, cut their comments.  This can just be a generic option: --help-with <f>
# ...


# executables
# Going to make a list of these...
# SQLITE3EX=
if [ ! -z $DO_EXECUTABLES ]
then
	# Die on no argument received.
	[ -z "$EXECUTABLES" ] && echo "Nothing supplied to --executables flag!" && usage 1
  	EXECUTABLES="$(break_list_by_delim "$EXECUTABLES")"

	# Don't want to run a find everytime for certain... 
	# printf 'dep_locate(){\n\tMOV_CHECK=( which, locate, find )\n\t'
	# printf 
	# dep_locate is going to point to which.  If there is no which you want this script to die.

	# Comments 
	( [ ! -z "$DO_COMMENTS" ] && printf "# Static variables\n"

	# Have the script run a check for each.
	for ETERM in ${EXECUTABLES[@]}
	do
		printf "${ETERM}=" | tr '[a-z]' '[A-Z]'
		[[ ! $ETERM == "sqlite" ]] && [[ ! $ETERM == "sqlite3" ]] && printf "\"\$(which ${ETERM} 2>/dev/null)\"\n" || printf "\"\$(which sqlite3 2>/dev/null)\"\n"
	done	

	# Have the script run a check for each.
	printf "DEPS=( "
	for ETERM in ${EXECUTABLES[@]}
	do
		printf "\"\$${ETERM}\" " | tr '[a-z]' '[A-Z]'
	done
	printf ")\n\n" ) >> $FILENAME	
fi


# program directory
if [ ! -z "$LIBNAME" ]
then
	# Always do the first few directories.
	( [ ! -z "$DO_COMMENTS" ] && printf "# Library and directory name\n"
	printf "LIBNAME=\"${LIBNAME}\"\n"
	printf "PROGRAM_DIR=\"\$HOME/.\${LIBNAME}\"\n" ) >> $FILENAME
fi


# create standard directories 
if [ ! -z $DO_STANDARD_DIRS ]
then
	# Everything else will break without some library name.
	[ -z "$LIBNAME" ] && echo "Must have a library name!" >> $FILEERR && usage 1

	# Die on no argument received.
	[ -z "$STANDARD_DIRS" ] && echo "Nothing supplied to --standard-dirs flag!" >> $FILEERR && usage 1
  	STANDARD_DIRS_ARR="$(break_list_by_delim "$STANDARD_DIRS")"

	# Die if there was no program directory.

	# Comments 
	( [ ! -z "$DO_COMMENTS" ] && printf "# Standard directories\n"

	# Have the script run a check for each.
	for SDIR in ${STANDARD_DIRS_ARR[@]}
	do
		printf "${SDIR}_DIR=" | tr '[a-z]' '[A-Z]'
		printf "\"\${PROGRAM_DIR}/${SDIR}\"\n"
	done	

	# Then host dirs.
	printf "HOST_DIRS=( \"\${PROGRAM_DIR}\" "
	for SDIR in ${STANDARD_DIRS_ARR[@]}
	do
		# Have to evaluate absolute names here, lest we don't want stuff in the program directory.	
		printf "\"\${PROGRAM_DIR}/${SDIR}\" "
	done	
	printf ")\n\n" ) >>  $FILENAME
fi


# Create static variables. 
if [ ! -z $DO_STATIC ]
then
	# Die on no argument received.
	[ -z "$STATIC" ] && echo "Nothing supplied to --static flag!" && usage 1
  	STATIC_ARR="$(break_list_by_delim "$STATIC")"

	# Comments 
	( [ ! -z "$DO_COMMENTS" ] && printf "# Static variables\n"

	# Have the script run a check for each.
	for SVAR in ${STATIC_ARR[@]}
	do
		if [[ "$SVAR" =~ "=" ]]
		then
			# Is this a key value pair
			printf ${SVAR%%=*} | tr '[a-z]' '[A-Z]'
			printf "=\"${SVAR##*=}\"\n"   

		else
			# If not, then just make a spot for it.
			printf "${SVAR}=\n" | tr '[a-z]' '[A-Z]'
		fi
	done ) >> $FILENAME	
fi


# db
if [ ! -z $DO_DB ]
then
 	( printf "DB=\"\${PROGRAM_DIR}/\${LIBNAME}.db\"\n"  
	printf "BIN_SQL_DIR=\"\${BINDIR}/sql\"\n\n"  ) >> $FILENAME
fi


# Add some function bodies.
if [ ! -z $DO_FUNCTIONS ]
then
	# Comments.
	( [ ! -z "$DO_COMMENTS" ] && printf "# Functions\n"

	# List some empty functions bodies.
  	FUNCTION_LIST="$(break_list_by_delim "$FUNCTION_LIST")"
	for FVAR in ${FUNCTION_LIST[@]}
	do
		if [[ "$FVAR" =~ "=" ]]
		then
			# Is this a key value pair
			printf "${FVAR%%=*}() {\n" 
		#	printf "=\"${FVAR##*=}\"\n"    # This doesn't work.  end...
			printf "${FVAR}" | sed 's/[a-z].*=//'
			printf "\n}\n" 
		else
			# If not, then just make a spot for it.
			printf "${FVAR}() {\n" 
			printf "   echo '...'"
			printf "\n}\n\n" 
		fi
	done ) >> $FILENAME
fi


# initial_run
if [ ! -z $DO_INITIAL_RUN ]
then
   ( 
	[ ! -z "$DO_COMMENTS" ] && printf "# Initial deployment.\n" 
	printf "initial_deploy() {\n" 

	[ ! -z "$DO_COMMENTS" ] && printf "\n\t# Some command handling.\n" 

	# Add some logic.
	printf "while [ \$# -gt 0 ]
	do
		case \"\$1\" in
			-n|--die-on-dependency-lack)
			DIE_ON_DEPEDENCY_LACK=true
			;;
		esac
		s\hift
	done\n\n"

	# Verbose eval.
	printf "\tif [ ! -z \$VERBOSE ] 
	then
		ID_MKDIR_FLAGS='-pv'	
	else
		ID_MKDIR_FLAGS='-p'	
	fi\n"

	if [ ! -z "$EXECUTABLES" ]
	then
		# Comments 
		[ ! -z "$DO_COMMENTS" ] && printf "\n\t# Run basic dependency checks.\n" 
		printf "\tfor E in \${DEPS[@]}\n\tdo " 

		printf "
		[ ! -z \$VERBOSE ] && echo 'Checking dependencies...\n'
		if [ -z \"\$E\" ] || [ ! -x \"\$E\" ] 
		then
			echo \"\$E is either not on this system or is not executable.\"
			[ ! -z \$DIE_ON_DEPENDENCY_LACK ] && exit 1
		else
			[ ! -z \$VERBOSE ] && echo \"\$(basename \$E) is present at: \$E.\"
		fi
	done\n"
	fi

	# Comments 
	[ ! -z "$DO_COMMENTS" ] && printf "\n\t# Create all directories in \$HOST_DIRS" 
	
	printf "
	for D in \${HOST_DIRS[@]}
	do
		mkdir \$ID_MKDIR_FLAGS \"\$D\"
	done" 
	
	
	# Comments 
	if [ ! -z $DO_DB ]
	then
		[ ! -z "$DO_COMMENTS" ] && printf "\n\n\t# Create tables" 

		printf "	
	for SD in \$( ls \$BIN_SQL_DIR )
	do
		[ ! -z \$VERBOSE ] && echo \"Loading tables in: \${BIN_SQL_DIR}/\$SD\"
		\$SQLITE \$DB < \${BIN_SQL_DIR}/\$SD
	done"
	fi

	printf '\n}\n'
	) >> $FILENAME
fi


# initial_install
if [ ! -z $DO_INITIAL_INSTALL ]
then
	(
	# Install somewhere.
	if [ ! -z "$INITIAL_INSTALL_DIR" ]
	then 
		if [ ! -z "$DO_COMMENTS" ] 
		then
			printf "\n# Install program where?\n" 
			printf "# ('/usr/bin', '/usr/local/bin', '\$HOME/bin' or another directory entirely.)" 
		fi

		printf "\nINITIAL_INSTALL_DIR=\"${INITIAL_INSTALL_DIR}\"\n"
	fi
	
	# Create the initial_install function
	printf "\ninitial_install() {\n"
	
	# Start moving through the function.
	[ ! -z "$DO_COMMENTS" ] && printf "\n# Initial install of program." 

	# Keep track of install directories.
	printf "\n\tSW_INSTALL=\"\${PROGRAM_DIR}/INSTALL\""

	# Catch args, there are some...
	printf "\n\t# Need some flags to catch install dir, arguments for what should be linked...
	while [ \$# -gt 0 ]
	do
		case "\$1" in
			--to) 
				shift
				INITIAL_INSTALL_DIR="\$1"
			;;
			--these) 
				shift
				LN_ARGS="\$1"
			;;
			-*)
			break
			;;
		esac
		shift
	done\n"

	# Be sane about evaluation.
	# If first arg is '/', then it's a dir.
	# If first arg is '/', then it's a dir.

	# Verbosity
	[ ! -z "$DO_COMMENTS" ] && printf "\t# Verbosity flags.\n"
	printf "\tif [ ! -z \$VERBOSE ] 
	then
		SW_LN_FLAGS='-sv'	
		SW_MKDIR_FLAGS='-pv'	
		SW_CHMOD_FLAGS='--verbose'	
	else
		SW_LN_FLAGS='-s'	
		SW_MKDIR_FLAGS='-p'	
		SW_CHMOD_FLAGS='--'	
	fi\n"

	# This needs to be run a little sooner.
	# Like at the deploy step.
	# Though the check still needs to be run here to make sure we can create
	# an uninstall routine.
	printf "
	if [ ! -d \"\$PROGRAM_DIR\" ] 
	then
		echo \"Program directory does not exist.\" 
		echo \"Exiting...\" 
		exit 1
	elif [ -d \"\$PROGRAM_DIR\" ] && [ ! -O \"\$PROGRAM_DIR\" ] 
	then
		echo \"Program directory is not writeable.  \"
		echo \"Exiting...\" 
		exit 1
	fi\n"
	
	# Set an initial install directory if not set yet. 
	[ ! -z "$DO_COMMENTS" ] && printf "\n\t# Set initial dir if not set.\n"
	printf "\tINITIAL_INSTALL_DIR=\"\${INITIAL_INSTALL_DIR:-'/usr/local/bin'}\"\n"


	# Check if the current user has write access or not.
	# Uninstall has to work here.
	[ ! -z "$DO_COMMENTS" ] && printf "\n\t# Die on no permissions if INITIAL_INSTALL_DIR is relative to /."

	printf "
	if [ -d \"\$INITIAL_INSTALL_DIR\" ] && [ ! -O \"\$INITIAL_INSTALL_DIR\" ] 
	then
		echo \"Install directory is not writeable.  Exiting...\" 
		exit 1
	fi\n"


	# Assume
	[ ! -z "$DO_COMMENTS" ] && printf "\n\t# Assume this directory could be impractically long."

	printf "
	if [ ! -d \"\$INITIAL_INSTALL_DIR\" ] 
	then
		mkdir \$SW_MKDIR_FLAGS \$INITIAL_INSTALL_DIR 2>/dev/null || SW_MKDIR_FAIL=true
		if [ ! -z \$SW_MKDIR_FAIL ] 
		then 
			echo \"Could not create \$INITIAL_INSTALL_DIR.  Exiting...\" 
			exit 1
		fi
	fi\n"


	# Do some more more magic.	
	[ ! -z "$DO_COMMENTS" ] && printf "\n\t# Check for what type of file exists in \$BINDIR" 

	printf "\n\tSW_INSTALLS=( \$(printf \$LN_ARGS | sed 's/,/ /g') )
	declare -a SW_LOCATIONS
	for FILE in \${SW_INSTALLS[@]}
	do
		# If a shell script, did we use an extension? (goal is to have no .sh in /bin)
		if [ -f \"\${BINDIR}/\${FILE}.sh\" ] 
		then 
			FILE=\"\${BINDIR}/\${FILE}.sh\" 
		elif [ -f \"\${BINDIR}/\${FILE}\" ] 
		then
			FILE=\"\${BINDIR}/\${FILE}\" 
		fi


		# Link 
		LNFILE=\"\$(basename \${FILE%%.sh})\" 

		# Quick test.
		if [ -L \"\$LNFILE\" ] 
		then 
			echo \"\${PROGRAM} already seems to be installed on this machine.\"
			echo \"You'll need to uninstall or remove those links first.\"
			exit
		fi


		# Set x bit, and link.
		[ ! -x \"\${FILE}\" ] && chmod \$SW_CHMOD_FLAGS 744 \${FILE}
		ln \$SW_LN_FLAGS \${FILE} \${INITIAL_INSTALL_DIR}/\$LNFILE


		# Save the software install location to a file.
		echo \"\${INITIAL_INSTALL_DIR}/\$LNFILE\" >> \$SW_INSTALL
	done
}\n"


	# This can be made to go into whatever as long as its parsed.
	# Load each var to memory and just save the results.
	[ ! -z "$DO_COMMENTS" ] && printf "\n# For what install would be complete without an uninstall?."

	# Add uninstall() function.
	printf "\nuninstall() {
	if [ ! -z \$VERBOSE ] 
	then
		UN_RM_FLAGS='-v --'	
	else
		UN_RM_FLAGS='--'	
	fi

	# Stop on problems accessing our install file (like it hasn't been created.)
	[ ! -f \$SW_INSTALL ] && echo \"Can't access INSTALL file.\" && exit 1
	while read line
	do
		rm \$UN_RM_FLAGS \$line
	done < \$SW_INSTALL

	# Trash the file.
	rm \$UN_RM_FLAGS \$SW_INSTALL
}\n"

	# total_uninstall?

	) >> $FILENAME
fi


# security
if [ ! -z $DO_SECURITY ]
then
	( printf '\n' >> $FILENAME
   # Set the right internal field seperator for command line args. 
	[ ! -z $DO_COMMENTS ] && printf "# Set the right internal field seperator for command line args.\n" 
	printf "IFS=' \n\t'\n\n"

	# Limits file creation permissions. 
	[ ! -z $DO_COMMENTS ] && printf "# Limits file creation permissions.\n" >> $FILENAME
	printf "UMASK=002\n" 
	printf 'umask $UMASK\n\n' 

	# Set a normal path. 
	[ ! -z $DO_COMMENTS ] && printf "# Set a normal path.\n" >> $FILENAME
	printf 'PATH="/usr/local/bin:/bin:/usr/bin:/usr/sbin:/usr/local/sbin"\n' 
	printf 'export PATH\n\n' ) >> $FILENAME
fi


# with
if [ ! -z $DO_WITH ]
then
	# specify_with
	if [ ! -z $DO_SPECIFY_WITH ]
	then
   	echo '...'
	fi

   # For each in the with list, cat.
	[ -z "$WITH" ] && echo "Nothing supplied to --with flag!" && usage 1
	WITH=$(break_list_by_delim "$WITH")	

	# Evaluate excludes.
	[ ! -z "$WITHOUT" ] && WITHOUT="$( break_list_by_delim "$WITHOUT" )"

	# Limits file creation permissions. 
	[ ! -z $DO_COMMENTS ] && printf "# Library functions\n" >> $FILENAME

	# Filenames.
	for LIB_F in ${WITH[@]}
	do
		# Get the filename.
		LIB_FILE="${SRCLIB}/$(grep $LIB_F $LOOKUP_MANIFEST | \
			awk -F ':' '{print $2}')"

		# Did the user ask that this function be excluded?
		[ ! -z "$WITHOUT" ] && \
			[[ $(is_element_present_in 'WITHOUT' "$LIB_F") == 'true' ]] && \
			continue 

		# Get the file body.
		if [ -f "$LIB_FILE" ]
		then
			FL=$(wc -l "$LIB_FILE" 2>/dev/null | cut -d ' ' -f 1)
			( sed -n 2,${FL}p $LIB_FILE
			printf "\n" ) >> $FILENAME
		fi	
	done
fi


# indiv groups
# I can save many lines with this...
if [ ! -z "$DO_BUILD" ]
then
	for BUILD_CHOICE in ${DO_BUILD[@]}
	do
		for FR in $( ls "$SRCLIB/$BUILD_CHOICE" ) 
		do
			# List each line.
			LIB_FILE="$SRCLIB/${BUILD_CHOICE}/${FR}"
			LIB_FNAME="$(basename ${BUILD_CHOICE}/${FR%%.sh})"
			FL=$(wc -l "$LIB_FILE" | cut -d ' ' -f 1)

			# Did the user ask that this be excluded?
			[ ! -z "$WITHOUT" ] && \
				[[ $(is_element_present_in 'WITHOUT' "$LIB_FNAME") == 'true' ]] && \
				continue 
			
			# Also evaluate namespaces here.
			# grep -n -v '#' $LIB_FILE  
			
			# Can get the first line this way kind of...
			# exit

			# You might not want comments. 
			if [ -f "$LIB_FILE" ] 
			then 
				( sed -n 2,${FL}p $LIB_FILE 
				printf "\n" ) >> "$FILENAME"
			fi
		done
	done
fi


# include all the libraries
if [ ! -z $DO_INC_ALL ]
then
	while read line
	do
		# Save this b/c it's our folder name for different lib functions.
		if [[ ${line:0:1} == '#' ]] || [[ -z "${line}" ]]
		then
			continue

		# Proc
		else
			FNAME="$(echo $line | awk -F ':' '{print $1}' )"
			LIB_FILE="$(echo $line | awk -F ':' '{print $2}' )"
			FL=$(wc -l "$LIB_FILE" 2>/dev/null | cut -d ' ' -f 1)

			# Did the user ask that this be excluded?
			[ ! -z "$WITHOUT" ] && \
				[[ $(is_element_present_in 'WITHOUT' "$FNAME") == 'true' ]] && \
				continue 

			# If the file doesn't exist, don't compile it.
			if [ -f "$LIB_FILE" ] 
			then 
				( sed -n 2,${FL}p $LIB_FILE 
				printf "\n" ) >> "$FILENAME"
			fi
		fi
	done < $LOOKUP_MANIFEST
fi


# include all the libraries
if [ ! -z $DO_LINKING ]
then
	# No directory specified. 
	[ -z "$LINK_AT" ] && echo "No directory specified for linking." && exit 1
	
	# Libs made with `bashutil` are always going to be under /lib 
	[[ ! $(basename "$LINK_AT") == "lib" ]] && LINK_AT="$LINK_AT/lib" 
	
	# Create this link directory. 
	[ ! -d "$LINK_AT" ] && mkdir $MKDIR_FLAGS $LINK_AT

	# Craft an OR query 
	for LIB in $(break_list_by_delim $LINK_WITH)
	do
		[ -z "$COMPLETE_OR" ] && COMPLETE_OR="name=$LIB" && continue
		COMPLETE_OR="${COMPLETE_OR} --or name=$LIB"
	done

	# Select location from this table.
	LINK_RESULTS=$(dbm --select 'location' --from libs --where $COMPLETE_OR)

	# A file for library includes...
	LIB_INC="$LINK_AT/__.sh"

	# Generate an array that will allow one to choose what 
	# should and should not be included.
	# (like source lib/*.sh)
	# (now namespaces are more important than ever...)
	( printf "%s\n" "#!/bin/bash" 
	printf "%s\n" "BASHUTIL_LIBS=(" ) > $LIB_INC

	# Craft a query.
	for FILE_FOUND in ${LINK_RESULTS[@]}
	do
		# Checksum of current file.
		# md5sum $COPIED_LIB

		COPIED_LIB="$LINK_AT/$(basename $FILE_FOUND)"
		if [ -f "$COPIED_LIB" ] 
		then
			# Get checksum and last modified date of both.
			# If checksum of COPIED_LIB is different from the original?
			# Supply overwrite to just blow away whatever's there...
			# md5sum $COPIED_LIB | awk '{print	$1}'
			printf 2>/dev/null
		fi


		# Store what's what lest my location changes for each link.
		SEED="$(dirname $LINK_AT)"
		FILE="$(basename $LINK_AT)"
		# dbm --insert-from-mem
		printf "\t%s" "'$(basename $LINK_AT)/$(basename $FILE_FOUND)'" >> $LIB_INC

		# Store the md5sum within the generated library file.
		# If the two are different, then updating can be automatically done...
		printf "%s\n" " # $(md5sum $SRCLIB/$FILE_FOUND | awk '{print $1}')" >> $LIB_INC

		# Link.
		[ ! -z $VERBOSE ] && LN_FLAGS="-v" || LN_FLAGS=""
		ln $LN_FLAGS $SRCLIB/$FILE_FOUND $COPIED_LIB 2>/dev/null
		unset LN_FLAGS
	done

	# Complete the generated library file.
	printf "%s\n" ")" >> $LIB_INC
	printf "for __MY_LIB__ in \${BASHUTIL_LIBS[@]}\ndo\n\tsource \"\$__MY_LIB__\"\ndone\n" >> $LIB_INC
fi
