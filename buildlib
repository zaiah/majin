#!/bin/bash -
#-----------------------------------------------------#
# buildlib
#
# Builds a portable library for shell script programs.
#-----------------------------------------------------#
#-----------------------------------------------------#
# Licensing
# ---------
# 
# Copyright (c) 2013 Vokayent
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#-----------------------------------------------------#
BINDIR="$(dirname "$(readlink -f $0)")"
SELF="$(readlink -f $0)"
LIB="${BINDIR}/lib.complete"
source $LIB
PROGRAM="buildlib"

# Manifests 
LIB_MANIFEST="lib/gen.manifest"
LOOKUP_MANIFEST="lib/lookup.manifest"

# Filenames
FILENAME="/dev/stdout"
FILEERR="/dev/stderr"

# Gotta deal with these within the lib.
DELIM=","
JOIN="="

# usage() - Show usage message and die with $STATUS
usage() {
   STATUS="${1:-0}"
   echo "Usage: ./${PROGRAM}
	[ -  ]

Library Compile Actions:
-w | --with <arg>             Build library with functions listed in <arg> 
-x | --without <arg>          Build library with functions listed in <arg> 
-z | --all                    Build library with functions listed in <arg> 
-n | --namespace <arg>        Build library functions with a different 
                              naming convention.
-c | --comments               Include comments in library. (default includes comments :) )
-l | --list                   List all available functions. 
-? | --describe <arg>         Describe function <arg>.
--specify-with                Use a menu to choose library list.

Library Macro Flags: 
-d | --databases              Concatenate only database functions into a library.
-g | --arguments              Concatenate only argument functions into a library.
-r | --random                 Concatenate only functions dealing with randomness into a library.
-s | --strings                Concatenate only string functions into a library.
-i | --integers               Concatenate only integer functions into a library.
-m | --math                   Concatenate only math functions into a library.
-a | --arrays                 Concatenate only array functions into a library. 
--from-groups <arg>           Build library with functions in group <arg>.
                              (Alternate syntax is supported) 

Library Runtime Actions:
-e | --executables <arg>      Convert names in <arg> to variables that alias
                              programs located in your \$PATH
-s | --static <arg>           Convert names in <arg> to variables pointing to 
                              immutable values. 
-d | --depcheck               Generate code to run a dependency check.
-s | --standard_dirs <arg>    Convert names in <arg> to variables that 
                              reference your program's common directories.
-b | --db                     Generate code to create a database. 
-t | --initial-run            Generate code to install a shell script.
-u | --security               Generate code to secure a shell script.

General Options:
-v | --verbose                Be verbose in output.
-h | --help                   Show this help and quit.
"
   exit $STATUS
}


# Die if no arguments received.
[ -z $BASH_ARGV ] && printf "Nothing to do\n" && usage 1

# Process options.
while [ $# -gt 0 ]
do
   case "$1" in
	  -c|--comments)
			DO_COMMENTS=true
		;;
     -w|--with)
         DO_WITH=true
         shift
         WITH="$1"
      ;;
     -l|--list)
         DO_LIST=true
         shift
         LIST="$1"
      ;;
     -n|--namespace)
         DO_NAMESPACE=true
         shift
         NAMESPACE="$1"
      ;;
     --specify-with)
         DO_WITH=true
         DO_SPECIFY_WITH=true
      ;;
     -e|--executables)
         DO_EXECUTABLES=true
         shift
         EXECUTABLES="$1"
      ;;
     -s|--static)
         DO_STATIC=true
         shift
         STATIC="$1"
      ;;
     -d|--depcheck)
         DO_DEPCHECK=true
      ;;
     -t|--standard-dirs)
         DO_STANDARD_DIRS=true
         shift
         STANDARD_DIRS="$1"
      ;;
     -b|--db)
         DO_DB=true
      ;;
     -i|--initial-run)
         DO_INITIAL_RUN=true
      ;;
     -s|--security)
         DO_SECURITY=true
      ;;
     -?|--describe)
         DO_DESCRIBE=true
         shift
         DESCRIBE="$1"
      ;;
      -v|--verbose)
        VERBOSE=true
      ;;
      -h|--help)
        usage 0
      ;;
      --)
		break
     ;;
      -*)
      printf "Bad argument.\n";
      exit 1
     ;;
      *) break;;
   esac
shift
done


# Verbosity
eval_flags




# list
if [ ! -z $DO_LIST ]
then
	# Regen doc.
	while read line
	do
		# Save this b/c it's our folder name for different lib functions.
		if [[ ${line:0:1} == '#' ]] 
		then
			printf "\nIn $(echo $line | sed 's/# //' | tr [A-Z] [a-z] ) library:\n"
			continue

		# Move through blanks.
		elif [[ -z "${line}" ]]
		then
			continue	

		# You have hit gold...
		else
			printf "  $line" | \
				sed 's/\r//' | \
				awk -F ':' '{print $1 ":          "}' | \
				head -c 25 
			printf "$line" | awk -F ':' '{print $2}' 
		fi
	done < $LIB_MANIFEST
fi


# Describe one thing at a time.
if [ ! -z $DO_DESCRIBE ]
then
	[ -z "$DESCRIBE" ] && echo "No description supplied!" && usage 1
	grep "$DESCRIBE" $LIB_MANIFEST
fi


# depcheck
if [ ! -z $DO_DEPCHECK ]
then
   echo '...'
fi


# executables
if [ ! -z $DO_EXECUTABLES ]
then
	# Die on no argument received.
	[ -z "$EXECUTABLES" ] && echo "Nothing supplied to --executables flag!" && usage 1
  	EXECUTABLES="$(break_list_by_delim "$EXECUTABLES")"

	# Don't want to run a find everytime for certain... 
	# printf 'dep_locate(){\n\tMOV_CHECK=( which, locate, find )\n\t'
	# printf 
	# dep_locate is going to point to which.  If there is no which you want this script to die.

	# Comments 
	( [ ! -z "$DO_COMMENTS" ] && printf "# Static variables\n"

	# Have the script run a check for each.
	for ETERM in ${EXECUTABLES[@]}
	do
		printf "${ETERM}=" | tr '[a-z]' '[A-Z]'
		printf "\"\$(which ${ETERM})\"\n"
	done	

	# Have the script run a check for each.
	printf "DEPS=( "
	for ETERM in ${EXECUTABLES[@]}
	do
		printf "\"\$${ETERM}\" " | tr '[a-z]' '[A-Z]'
	done
	printf ")\n\n" ) >> $FILENAME	
fi


# create standard directories 
if [ ! -z $DO_STANDARD_DIRS ]
then
	# Die on no argument received.
	[ -z "$STANDARD_DIRS" ] && echo "Nothing supplied to --standard-dirs flag!" >> $FILEERR && usage 1
  	STANDARD_DIRS_ARR="$(break_list_by_delim "$STANDARD_DIRS")"

	# Comments 
	[ ! -z "$DO_COMMENTS" ] && printf "# Standard directories\n"

	# Always do the first few directories.
	printf "PROGRAM_DIR=\"\$HOME/.\${PROGRAM}\"\n"

	# Have the script run a check for each.
	for SDIR in ${STANDARD_DIRS_ARR[@]}
	do
		printf "${SDIR}_DIR=" | tr '[a-z]' '[A-Z]'
		printf "\"\${PROGRAM_DIR}/${SDIR}\"\n"
	done	

	# Then host dirs.
	printf "HOST_DIRS=( \"\${PROGRAM_DIR}\" "
	for SDIR in ${STANDARD_DIRS_ARR[@]}
	do
		# Have to evaluate absolute names here, lest we don't want stuff in the program directory.	
		printf "\"\${PROGRAM_DIR}/${SDIR}\" "
	done	
	printf ")\n\n" 
fi


# Create static variables. 
if [ ! -z $DO_STATIC ]
then
	# Die on no argument received.
	[ -z "$STATIC" ] && echo "Nothing supplied to --static flag!" && usage 1
  	STATIC_ARR="$(break_list_by_delim "$STATIC")"

	# Comments 
	[ ! -z "$DO_COMMENTS" ] && printf "# Static variables\n"

	# Have the script run a check for each.
	for SVAR in ${STATIC_ARR[@]}
	do
		if [[ "$SVAR" =~ "=" ]]
		then
			# Is this a key value pair
			printf ${SVAR%%=*} | tr '[a-z]' '[A-Z]'
			printf "=\"${SVAR##*=}\"\n"   

		else
			# If not, then just make a spot for it.
			printf "${SVAR}=\n" | tr '[a-z]' '[A-Z]'
		fi
	done	
fi


# db
if [ ! -z $DO_DB ]
then
 	printf "DB=\"${PROGRAM_DIR}/${PROGRAM}.db\"\n"  
 	printf "BIN_SQL_DIR=\"${BINDIR}/sql\"\n\n"  
fi


# initial_run
if [ ! -z $DO_INITIAL_RUN ]
then
   ( 
	[ ! -z "$DO_COMMENTS" ] && printf "# Initial deployment.\n" >> $FILENAME
	printf "initial_deploy() {\n\tfor E in \${DEPS[@]}\n\tdo " >> $FILENAME

	# Comments 
	[ ! -z "$DO_COMMENTS" ] && printf "\n\t\t# Run basic dependency checks." >> $FILENAME

	printf "
		if [ -z \"\$E\" ] || [ ! -x \"\$E\" ] 
		then
			echo \"\$E is not on system.\"
			exit 1
		fi
	done
	" >> $FILENAME

	# Comments 
	[ ! -z "$DO_COMMENTS" ] && printf "\n\t# Create all directories in \$HOST_DIRS" >> $FILENAME
	
	printf "
	for D in \${HOST_DIRS[@]}
	do
		mkdir -p \"\$D\"
	done" >> $FILENAME
	
	
	# Comments 
	if [ ! -z $DO_DB ]
	then
		[ ! -z "$DO_COMMENTS" ] && printf "\n\n\t# Create tables" >> $FILENAME

		printf "	
	for SD in \$( ls \$BIN_SQL_DIR )
	do
		\$SQLITE \$DB < \$SD
	done"
	fi

	printf '\n}\n'
	) >> $FILENAME
fi


# security
if [ ! -z $DO_SECURITY ]
then
	printf '\n' >> $FILENAME
   # Set the right internal field seperator for command line args. 
	# [ ! -z $DO_COMMENTS ] && printf "# Set the right internal field seperator for command line args." >> $FILENAME
	# printf "IFS=' \n\t'"  >> $FILENAME

	# Limits file creation permissions. 
	[ ! -z $DO_COMMENTS ] && printf "# Limits file creation permissions.\n" >> $FILENAME
	( printf "UMASK=002\n" 
	printf 'umask $UMASK\n\n' ) >> $FILENAME

	# Set a normal path. 
	[ ! -z $DO_COMMENTS ] && printf "# Set a normal path.\n" >> $FILENAME
	( printf 'PATH="/usr/local/bin:/bin:/usr/bin"\n' 
	printf 'export PATH\n' ) >> $FILENAME
fi


# with
if [ ! -z $DO_WITH ]
then
	# specify_with
	if [ ! -z $DO_SPECIFY_WITH ]
	then
   	echo '...'
	fi

   # For each in the with list, cat.
	[ -z "$WITH" ] && echo "Nothing supplied to --with flag!" && usage 1
	WITH=$(break_list_by_delim "$WITH")	

	# Lines.
	while read line
	do
		# Save this b/c it's our folder name for different lib functions.
		if [[ ${line:0:1} == '#' ]] 
		then
			continue

		# Move through blanks.
		elif [[ -z "${line}" ]]
		then
			continue	

		# You have hit gold...
		else
			printf "  $line" | \
				sed 's/\r//' | \
				awk -F ':' '{print $1 ":          "}' | \
				head -c 25 
			printf "$line" | awk -F ':' '{print $2}' 
		fi
	done < $LOOKUP_MANIFEST
fi


