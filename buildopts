#!/bin/bash -
#-----------------------------------------------------#
# buildopts.sh
#
# Builds out the innards of a shell script.
#
# ---------
# Licensing
# ---------
# 
# Copyright (c) 2013 Vokayent
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#-----------------------------------------------------#
BINDIR="$(dirname "$(readlink -f $0)")"
SELF="$(readlink -f $0)"
LIB="${BINDIR}/lib.complete"
source $LIB
PROGRAM="buildopts"
DELIM=","
JOIN="="


# usage message
# Show a usage message and die.
usage() {
	STATUS=${1:-0}
	echo "
./$PROGRAM [ - ]

General options:
-f | --from <list>          Supply a list of options to create flags for.
-g | --generate             Generate a new manifest file.
-c | --clobber              Overwrite file if one exists.

Shell Script tuning:
-d | --die-on-no-arg        Make changes on <file>.
-s | --summary <summ>       Add a quick summary.
-e | --license <type>       Add a particular license at the top of the script.
-l | --logic                Generate accompanying logic.
-n | --name <name>          Set up a script name.
-p | --program <name>       Set up a script name and use this name in a \$PROGRAM variable.
-o | --options              Generate a list of options.
-x | --only-options <list>  Do not generate logic for items in list.
-t | --to <file>            Make changes on <file>.
-u | --usage <file>         Make changes on <file>.
-z | --shell <type>         Choose a particular shell for she-bang line.
                            (Default is bash)
-m | --from-manifest        Generate through the use of a manifest file.
-b | --binref               Include references to script file and directory 
                            that script resides in.
-y | --libref               Include references to library 
-a | --all <arg>            Set all flags that don't require an argument.
                            <arg> is the name of the script.

General Options:
-v | --verbose              Be verbose in output.
-h | --help                 Show help and quit.
"
	exit $STATUS
}


# push_option_alpha() - Chooses distinct letters for options.
# If an option letter is taken, use something else within the string first.
# SLOW AS HELL!!!
declare -a OPTION_ALPHA 
push_option_alpha() {
	# Create array.
	if [ ${#OPTION_ALPHA[@]} -eq 0 ]
	then 
		#echo Not filled: ${#OPTION_ALPHA[@]}
		OPTION_ALPHA[0]="h"
		OPTION_ALPHA[1]="v"
	fi

	#echo Modified: ${#OPTION_ALPHA[@]}
	#echo $(is_element_present_in "OPTION_ALPHA" $1)

	# Push to it.
	if [ ! -z "$1" ] 
	then
		# ...
		if [ $(is_element_present_in "OPTION_ALPHA" $1) == false ]
		then
			OPTION_ALPHA[${#OPTION_ALPHA[@]}]="$1"

		# Choose a new letter.
		else
			for n in `seq 0 $(( ${#OPT_NAME} - 1 ))`
			do
				OPT_ALP_LETTER=${OPT_NAME:${n}:1}

				# Break on hyphens.
				if [[ $OPT_ALP_LETTER == '-' ]]
				then
					continue

				# Keep moving.
				elif [ $(is_element_present_in "OPTION_ALPHA" $OPT_ALP_LETTER) == false ]
				then
					OPTION_ALPHA[${#OPTION_ALPHA[@]}]=${OPT_ALP_LETTER}
					OPT_ALP_SET=true
					break
				fi
			done

			# Oh no!  What if we still couldn't find a letter?
			# (We've reached the end of the food chain...)
			# There is a better  way to do this... ( LETTERS=$( echo [a-z] ) )
			declare -a OA_LETTERS
			OA_LETTERS=(a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9)	
			for OAL in ${OA_LETTERS[@]}
			do
				if [ $(is_element_present_in "OPTION_ALPHA" $OAL) == false ]
				then
					OPTION_ALPHA[${#OPTION_ALPHA[@]}]=${OAL}
					OPT_ALP_SET=true
					break
				fi	
			done	
		fi
	fi
#	printf ${OPTION_ALPHA[$(( ${#OPTION_ALPHA[@]} - 1 ))]}
}


# get_last_alpha() - Still unsure as to why I need this...
get_last_alpha () {
	printf ${OPTION_ALPHA[$(( ${#OPTION_ALPHA[@]} - 1 ))]}
}


# Die if no string received.
[ -z "$BASH_ARGV" ] && echo "Nothing to do." && usage 1
while [ $# -gt 0 ]
do
	case "$1" in 
		-a|--all)
			PROC_ALL=true
			DO_SELFSOURCE=true
			DO_LIBSOURCE=true
			DO_PROGRAM=true
			SHOW_USAGE=true
			DO_COMMENTS=true
			DO_DIENARG=true
			SELECT_LICENSE=true
			DO_LOGIC=true
			DO_OPTIONS=true
			shift
			NAME="$1"
		;;

		-b|--binref)
			DO_SELFSOURCE=true
		;;

		-y|--libref)
			shift
			LIBREF="$1"
		;;

		-s|--summary)
			shift
			SUMMARY="$1"
		;;

		-f|--from)
			shift
			FROM=$1
		;;

		-p|--program)
			DO_PROGRAM=true
			shift
			NAME="$1"
		;;

		-g|--generate)
			GENERATE=true
		;;

		-c|--comments)
			DO_COMMENTS=true
		;;

		-a|--according-to)
			shift
			ACC_FILE=$1
		;;

		-d|--die-on-no-arg)
			DO_DIENARG=true
		;;

		-e|--license)
			SELECT_LICENSE=true
			shift
			LICENSE=$1
		;;

		-l|--logic)
			DO_LOGIC=true
		;;
		
		-m|--modify)
			MODIFY=true
			shift
			FILENAME=$1
		;;

		-z|--shell)
			shift
			SHELL_ARG="$1"
		;;
		-n|--name)
			shift
			NAME=$1
		;;

		-o|--options)
			DO_OPTIONS=true
		;;

		-x|--only-options)
			shift
			ONLY_OPTIONS="$1"
		;;

		-t|--to)
			shift
			FILENAME=$1
		;;

		-u|--usage)
			SHOW_USAGE=true
		;;

		-v|--verbose)
		usage 0
		;;

		-h|--help)
		usage 0
		;;

		--)
		;;

		-*) echo "Unknown argument received."
			 usage 1
		;;

		*) break # Is this smart?
		;;
	esac
shift
done

# No more processing needed.
if [ -z $DO_LOGIC ] && \
	[ -z $SELECT_LICENSE ] && \
	[ -z $DO_OPTIONS ] && \
	[ -z $SHOW_USAGE ] && \
	[ -z "$SUMMARY" ] && \
	[ -z "$NAME" ]
then
	echo "Nothing to do!"
	usage 1
fi


# --all must have a list via --from.
if [ ! -z $PROC_ALL ] && [ -z "$FROM" ]
then
	echo "No list supplied via --from!"
	echo "Can't create options or usage menu without at least one argument here."
	usage 1
fi


# Generate a file.
FILENAME=${FILENAME:-'/dev/stdout'}
FILEERR=${FILENAME:-'/dev/stderr'}
if [[ ! $FILENAME == '/dev/stdout' ]] && [ -f $FILENAME ] 
then
	rm $RM_FLAGS $FILENAME
fi


# Choose a shell.
SHELL=
case "$SHELL_ARG" in
	s|sh|SH|sH|Sh)
		SHELL="sh"
	;;
	z|zsh|ZSH|zSH|zSh|Zsh|ZsH)
		SHELL="zsh"
	;;
	b|bash)
		SHELL="bash"
	;;
	c|csh|CSH|cSH|cSh|Csh|CsH)
		SHELL="csh"
	;;
	k|ksh|KSH|kSH|kSh|Ksh|KsH)
		SHELL="ksh"
	;;
	*)
		SHELL="bash"
	;;
esac
printf "#!/bin/${SHELL} -\n" >> $FILENAME



# Choose a shell.
if [ ! -z "$NAME" ] || [ ! -z "$SUMMARY" ]
then
	( printf '#-----------------------------------------------------#\n'
	printf "# $NAME\n" 
	printf '#\n'
	printf "# $SUMMARY\n"
	printf '#-----------------------------------------------------#\n'
	) >> $FILENAME
fi


# Choose licenses.
if [ ! -z $SELECT_LICENSE ]
then
	case $LICENSE in
		mit)
LICENSE_BODY='#-----------------------------------------------------#
# Licensing
# ---------
# 
# Copyright (c) 2013 Vokayent
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#-----------------------------------------------------#\n'
		;;

		gpl)
LICENSE_BODY="

"
		;;

	esac
	printf "$LICENSE_BODY" >> $FILENAME
fi

# Use $PROGRAM variable.
[ ! -z $DO_PROGRAM ] && printf "PROGRAM=\"${NAME}\"\n" >> $FILENAME


# Include a reference to self and the program's directory.
if [ ! -z $DO_SELFSOURCE ] || [ ! -z "$LIBREF" ]
then
	[ ! -z $DO_COMMENTS ] && printf '\n# References to $SELF\n' >> $FILENAME
	( printf 'BINDIR="$(dirname "$(readlink -f $0)")"\n'
	printf 'SELF="$(readlink -f $0)"\n' ) >> $FILENAME

	if [ ! -z "$LIBREF" ] 
	then 
		[ ! -z $DO_COMMENTS ] && printf '\n# Reference a central library\n' >> $FILENAME
		printf "LIB=\"\${BINDIR}/${LIBREF}\"\nsource \$LIB\n" >> $FILENAME
	fi
fi


# Need the ability to choose between action flags and logic / arugment flags.
# If there's no list, manifest or file to read, this is pretty much useless.
if [ -z "$FROM" ] || [[ "${FROM:0:1}" == '-' ]]
then 
	if [ ! -z $SHOW_USAGE ] || \
		[ ! -z $DO_OPTIONS ] || \
		[ ! -z $DO_LOGIC ] || \
		[ ! -z $ONLY_OPTIONS ]
	then
	echo "No list supplied via --from!" >> $FILEERR
	usage 1
	else
		exit 0
	fi
fi


# Catch arguments here if we want them.
OPTS_FROM_LIST=( $( break_list_by_delim $FROM ) )
if [ ! -z "$ONLY_OPTIONS" ] 
then 
	NO_OPT_FROM_LIST=( $( break_list_by_delim $ONLY_OPTIONS ) )
fi


# Break up arguments before moving further.
COUNTER=0
declare -a ARG_SUB_SET
declare -a GENERATE_LOGIC_SET
for EACH_ARG in ${OPTS_FROM_LIST[@]}
do
	# ...
	if [[ ${EACH_ARG:0:1} == '@' ]] 
	then 
 		ARG_SUB_SET[$COUNTER]=true 
	else
 		ARG_SUB_SET[$COUNTER]=false
	fi

	# Set no logic.
	if [ ! -z "$NO_OPT_FROM_LIST" ]
	then
		if [ $( is_element_present_in "NO_OPT_FROM_LIST" $EACH_ARG ) == true ] || \
			[ $( is_element_present_in "NO_OPT_FROM_LIST" ${EACH_ARG:1:${#EACH_ARG}} ) == true ]
		then
 			GENERATE_LOGIC_SET[$COUNTER]=true 
		else
 			GENERATE_LOGIC_SET[$COUNTER]=false
		fi
	fi

	COUNTER=$(( $COUNTER + 1 ))
done	
unset COUNTER


# Move forward with setting flags.
ARG_FLAG_SET=( $(echo ${OPTS_FROM_LIST[@]} | tr [a-z] [A-Z] | tr '-' '_') )
COUNTER=0
LIM=$(( ${#OPTS_FROM_LIST[@]} - 1 ))


# Show a usage message.
if [ ! -z $SHOW_USAGE ]
then
	# Print any comments. 
	[ ! -z $DO_COMMENTS ] && printf '\n# usage() - Show usage message and die with $STATUS\n' >> $FILENAME

	# Eventually add option for top tags.
	( printf 'usage() {\n'
	printf '   STATUS="${1:-0}"\n'
	printf '   echo "Usage: ./${PROGRAM}\n\t[ -  ]\n\n' ) >> $FILENAME

	# Logic
	for OPTCOUNT in `seq $COUNTER $LIM`
	do
		# Print formatted help with additional arguments.
		if [[ ${ARG_SUB_SET[$OPTCOUNT]} == true ]]
		then
			ARG_FLAG_NAME="${ARG_FLAG_SET[$OPTCOUNT]:1:${#ARG_FLAG_SET[$OPTCOUNT]}}"
			OPT_NAME="$( echo ${ARG_FLAG_NAME} | tr [A-Z] [a-z] )"
		#	ARG_LETTER=`push_option_alpha ${OPT_NAME:0:1}`
		#	push_option_alpha ${OPT_NAME:0:1}
		#	ARG_LETTER="$(get_last_alpha)"
			ARG_LETTER="${OPT_NAME:0:1}"

			printf -- \
				"$(printf -- "-${ARG_LETTER} | --${OPT_NAME} <arg>                     " | \
				head -c 30)" >> $FILENAME
			printf "desc\n" >> $FILENAME

		# Print formatted help without arguments.
		else
			OPT_NAME="$( echo ${OPTS_FROM_LIST[$OPTCOUNT]} | tr [A-Z] [a-z] )"
#			ARG_LETTER=$(push_option_alpha ${OPT_NAME:0:1})
	#		push_option_alpha ${OPT_NAME:0:1}
	#		ARG_LETTER="$(get_last_alpha)"
			ARG_LETTER="${OPT_NAME:0:1}"

			printf -- \
				"$(printf -- "-${ARG_LETTER} | --${OPTS_FROM_LIST[$OPTCOUNT]}                      " | \
				head -c 30)" >> $FILENAME
			printf "desc\n" >> $FILENAME
		fi
	done

	printf -- '-v | --verbose                 ' | head -c 30 >> $FILENAME 
	printf 'Be verbose in output.\n' >> $FILENAME
	printf -- '-h | --help                    ' | head -c 30 >> $FILENAME
	( printf 'Show this help and quit.\n"\n' 
	printf '   exit $STATUS\n'
	printf '}\n\n' ) >> $FILENAME
fi


# Die on no arguments.
if [ ! -z $DO_DIENARG ]
then
	# Print any comments. 
	[ ! -z $DO_COMMENTS ] && printf '\n# Die if no arguments received.' >> $FILENAME

	# Die!
	printf '\n[ -z $BASH_ARGV ] && printf "Nothing to do\\n" && usage 1\n' >> $FILENAME
fi



# Process all the options.
unset OPTION_ALPHA
if [ ! -z $DO_OPTIONS ]
then
	# Print any comments. 
	[ ! -z $DO_COMMENTS ] && printf '\n# Process options.' >> $FILENAME

	# Do some basics.
	( printf '\nwhile [ $# -gt 0 ]\ndo\n'
	printf '   case "$1" in\n' ) >> $FILENAME


	# Generate list of options. 
	for OPTCOUNT in `seq $COUNTER $LIM`
	do
		#printf "Argument: ${ARG_SUB_SET[$OPTCOUNT]}"

		if [[ ${ARG_SUB_SET[$OPTCOUNT]} == true ]]
		then
			ARG_FLAG_NAME="${ARG_FLAG_SET[$OPTCOUNT]:1:${#ARG_FLAG_SET[$OPTCOUNT]}}"
			OPT_NAME="$( echo ${ARG_FLAG_NAME} | tr [A-Z] [a-z] )"

			# This is ridiculous...
			#push_option_alpha ${OPT_NAME:0:1}
			#ARG_LETTER="$(get_last_alpha)"
			ARG_LETTER=${OPT_NAME:0:1}

			# Can optionally loop these to go through whole range.
			# Also need to check if this first letter is a member of an array.
			#( printf -- "     -${OPT_NAME:0:1}|"
			( printf -- "     -${ARG_LETTER}|"
			printf -- "--${OPT_NAME})\n"

			# Wants arg or not?
			printf "         DO_$ARG_FLAG_NAME=true\n"
			printf "         shift\n"
			printf "         ${ARG_FLAG_NAME}=\"\$1\"\n" ) >> $FILENAME

			# Unset for the next round.
			unset ARG_FLAG_NAME
			unset OPT_NAME
		else
			# This is ridiculous...
			#push_option_alpha ${OPTS_FROM_LIST[$OPTCOUNT]:0:1}
			#ARG_LETTER="$(get_last_alpha)"
			ARG_LETTER=${OPTS_FROM_LIST[$OPTCOUNT]:0:1}

			#( printf -- "     -${OPTS_FROM_LIST[$OPTCOUNT]:0:1}|"
			( printf -- "     -${ARG_LETTER}|"
			printf -- "--${OPTS_FROM_LIST[$OPTCOUNT]})\n"
			printf "         DO_${ARG_FLAG_SET[$OPTCOUNT]}=true\n" ) >> $FILENAME
		fi

		printf "      ;;\n" >> $FILENAME
	done	


	# End the flags.
 ( printf '     -v|--verbose)\n        VERBOSE=true\n      ;;\n' 
   printf '     -h|--help)\n        '

	# Show the correct exit code.
	if [ ! -z $SHOW_USAGE ]
	then
		printf 'usage 0\n      ;;\n' 			# Only if USAGE was asked for.
	else
		printf 'exit 0\n       ;;\n'
	fi

	# Catch the signal for the end of the flags.
 	printf '     --) break;;\n'

	# Catch unknown flags and show correct exit code.
 	printf '     -*)\n   ' 
	printf '   printf \"Unknown argument received.\\n\";\n'
	if [ ! -z $SHOW_USAGE ]
	then
		printf '      usage 1\n     ;;\n'
	else
		printf '      exit 1\n     ;;\n'
	fi

	# Skip arguments.
	printf '     *) break;;\n'
	printf '   esac\nshift\n'	
	printf 'done\n' ) >> $FILENAME
fi


# Process all the logic.
if [ ! -z $DO_LOGIC ]
then
	# Logic
	for OPTCOUNT in `seq $COUNTER $LIM`
	do
		# ...
		if [[ ${GENERATE_LOGIC_SET[$OPTCOUNT]} == true ]]
		then
			continue
		elif [[ ${ARG_SUB_SET[$OPTCOUNT]} == true ]]
		then
			ARG_FLAG_NAME="${ARG_FLAG_SET[$OPTCOUNT]:1:${#ARG_FLAG_SET[$OPTCOUNT]}}"

			# Print any comments. 
			[ ! -z $DO_COMMENTS ] && printf "\n# $(printf ${ARG_FLAG_NAME} | tr '[A-Z]' '[a-z]')" >> $FILENAME

			# Then print the flag.
			printf "\nif [ ! -z \$DO_${ARG_FLAG_NAME} ]\n" >> $FILENAME
		else
			# Print any comments. 
			[ ! -z $DO_COMMENTS ] && printf "\n# $(printf ${ARG_FLAG_SET[$OPTCOUNT]} | tr '[A-Z]' '[a-z]')" >> $FILENAME

			printf "\nif [ ! -z \$DO_${ARG_FLAG_SET[$OPTCOUNT]} ]\n" >> $FILENAME
		fi

		( printf "then\n"
		printf "   echo '...'\n"
		printf "fi\n" ) >> $FILENAME
	done
fi
